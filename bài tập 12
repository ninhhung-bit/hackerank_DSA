12.1 /// Cho mảng hai chiều với các phần tử (ô) có giá trị là 0 hoặc 1. Hai phần từ được gọi là kết nối (connected) với
nhau nếu chúng cùng có giá trị là 1 và ở sát nhau theo chiều ngang, chiều dọc và chéo cạnh. Như thế mỗi ô có thể có nhiều nhất 8 ô ở kề nối với nó.


public static int connectedCell(List<List<Integer>> matrix) {

        int n = matrix.size();
        int m = matrix.get(0).size();
        int maxRegion = 0;

        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
        
        java.util.function.BiFunction<Integer, Integer, Integer> dfs 
        = new java.util.function.BiFunction<Integer, Integer, Integer>() {
            @Override
            public Integer apply(Integer x, Integer y) {
          
                if (x < 0 || x >= n || y < 0 || y >= m || matrix.get(x).get(y) != 1) {
                    return 0;
                }
                
                matrix.get(x).set(y, 0);  // gan 0 vao vi tri xy

                int count = 1;
                for (int dir = 0; dir < 8; dir++) {
                    count += this.apply(x + dx[dir], y + dy[dir]);
                }
                
                return count;
            }
        };
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix.get(i).get(j) == 1) {
                    int size = dfs.apply(i, j);
                    maxRegion = Math.max(maxRegion, size);
                }
            }
        }
        
        return maxRegion;
    }




12.2 // Cho đồ thị vô hướng; các đỉnh đánh số từ 1 tới n; hai cạnh nếu nối với nhau thì có trọng số luôn là 6. Cho vào đỉnh xuất phát,
hãy tìm và in đường đi ngắn nhất từ đỉnh này tới (n-1) đỉnh còn lại. Nếu không có đường đi thì in ra -1.


 public static List<Integer> bfs(int n, int m, List<List<Integer>> edges, int s) {

    List<List<Integer>> adj = new ArrayList<>();    //  2 chiều
    for (int i = 0; i <= n; i++) {
        adj.add(new ArrayList<>());      // thêm danh sách kề cho mỗi đỉnh
    }

    for (List<Integer> edge : edges) {
        int u = edge.get(0);
        int v = edge.get(1);
        adj.get(u).add(v);        // thêm v vào danh sách kề của u
        adj.get(v).add(u);        // thêm u vào danh sách  kề của v
    }

    int[] dist = new int[n + 1];    // mảng lưu khoảng cách 
    Arrays.fill(dist, -1);      // ban đầu gán -1 hết
    dist[s] = 0;                // đỉnh xuất phát

    Queue<Integer> q = new LinkedList<>();
    q.add(s);

    while (!q.isEmpty()) {
        int cur = q.poll();
        for (int next : adj.get(cur)) {
            if (dist[next] == -1) {
                dist[next] = dist[cur] + 6;  
                q.add(next);
            }
        }
    }

    
    List<Integer> result = new ArrayList<>();
    for (int i = 1; i <= n; i++) {
        if (i != s) {
            result.add(dist[i]);
        }
    }

    return result;
   }









